From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Alex Bradbury <asb@lowrisc.org>
Subject: [RISCV] Support lowering FrameIndex

---
 lib/Target/RISCV/RISCVISelDAGToDAG.cpp | 24 ++++++++++++++++++++++++
 lib/Target/RISCV/RISCVInstrInfo.cpp    |  4 ++--
 lib/Target/RISCV/RISCVInstrInfo.td     | 18 ++++++++++++++++++
 lib/Target/RISCV/RISCVRegisterInfo.cpp | 33 ++++++++++++++++++++++++++++++---
 test/CodeGen/RISCV/frame.ll            | 33 +++++++++++++++++++++++++++++++++
 5 files changed, 107 insertions(+), 5 deletions(-)
 create mode 100644 test/CodeGen/RISCV/frame.ll

diff --git a/lib/Target/RISCV/RISCVISelDAGToDAG.cpp b/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
index 94b6ce76be2..7e661089323 100644
--- a/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
+++ b/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
@@ -37,6 +37,8 @@ public:
 
   void Select(SDNode *Node) override;
 
+  bool SelectADDRii(SDValue Addr, SDValue &Base, SDValue &Offset);
+
 // Include the pieces autogenerated from the target description.
 #include "RISCVGenDAGISel.inc"
 };
@@ -79,6 +81,28 @@ void RISCVDAGToDAGISel::Select(SDNode *Node) {
   SelectCode(Node);
 }
 
+bool RISCVDAGToDAGISel::SelectADDRii(SDValue Addr, SDValue &Base,
+                                     SDValue &Offset) {
+
+  FrameIndexSDNode *FIN = nullptr;
+  if ((FIN = dyn_cast<FrameIndexSDNode>(Addr))) {
+    Base = CurDAG->getTargetFrameIndex(FIN->getIndex(), MVT::i32);
+    Offset = CurDAG->getTargetConstant(0, SDLoc(Addr), MVT::i32);
+    return true;
+  }
+  if (Addr.getOpcode() == ISD::ADD || Addr.getOpcode() == ISD::OR) {
+    ConstantSDNode *CN = nullptr;
+    if ((FIN = dyn_cast<FrameIndexSDNode>(Addr.getOperand(0))) &&
+        (CN = dyn_cast<ConstantSDNode>(Addr.getOperand(1)))) {
+      Base = CurDAG->getTargetFrameIndex(FIN->getIndex(), MVT::i32);
+      Offset =
+          CurDAG->getTargetConstant(CN->getSExtValue(), SDLoc(Addr), MVT::i32);
+      return true;
+    }
+  }
+  return false;
+}
+
 // This pass converts a legalized DAG into a RISCV-specific DAG, ready
 // for instruction scheduling.
 FunctionPass *llvm::createRISCVISelDag(RISCVTargetMachine &TM) {
diff --git a/lib/Target/RISCV/RISCVInstrInfo.cpp b/lib/Target/RISCV/RISCVInstrInfo.cpp
index c5a0288259d..dca1dda9e15 100644
--- a/lib/Target/RISCV/RISCVInstrInfo.cpp
+++ b/lib/Target/RISCV/RISCVInstrInfo.cpp
@@ -55,7 +55,7 @@ void RISCVInstrInfo::storeRegToStackSlot(MachineBasicBlock &MBB,
     DL = I->getDebugLoc();
 
   if (RC == &RISCV::GPRRegClass)
-    BuildMI(MBB, I, DL, get(RISCV::SW))
+    BuildMI(MBB, I, DL, get(RISCV::SW_FI))
         .addReg(SrcReg, getKillRegState(IsKill))
         .addFrameIndex(FI)
         .addImm(0);
@@ -73,7 +73,7 @@ void RISCVInstrInfo::loadRegFromStackSlot(MachineBasicBlock &MBB,
     DL = I->getDebugLoc();
 
   if (RC == &RISCV::GPRRegClass)
-    BuildMI(MBB, I, DL, get(RISCV::LW), DestReg).addFrameIndex(FI).addImm(0);
+    BuildMI(MBB, I, DL, get(RISCV::LW_FI), DestReg).addFrameIndex(FI).addImm(0);
   else
     llvm_unreachable("Can't load this register from stack slot");
 }
diff --git a/lib/Target/RISCV/RISCVInstrInfo.td b/lib/Target/RISCV/RISCVInstrInfo.td
index 45f703d5ca4..7a3265722dd 100644
--- a/lib/Target/RISCV/RISCVInstrInfo.td
+++ b/lib/Target/RISCV/RISCVInstrInfo.td
@@ -97,6 +97,14 @@ def simm21_lsb0 : Operand<OtherVT> {
   let DecoderMethod = "decodeSImmOperandAndLsl1<21>";
 }
 
+// Addressing modes
+def ADDRii : ComplexPattern<i32, 2, "SelectADDRii", [add, frameindex], []>;
+
+// Address operands
+def MEMii : Operand<i32> {
+  let MIOperandInfo = (ops i32imm, i32imm);
+}
+
 // Extract least significant 12 bits from an immediate value and sign extend
 // them.
 def LO12Sext : SDNodeXForm<imm, [{
@@ -224,6 +232,9 @@ defm : LD_Pat<load, LW>;
 defm : LD_Pat<zextloadi8, LBU>;
 defm : LD_Pat<zextloadi16, LHU>;
 
+def LW_FI : Pseudo<(outs GPR:$dst), (ins MEMii:$addr),
+                 [(set GPR:$dst, (load ADDRii:$addr))]>;
+
 // Operands for stores are in the order srcreg, base, offset rather than
 // reflecting the order these fields are specified in the instruction
 // encoding.
@@ -247,6 +258,9 @@ defm : ST_Pat<truncstorei8, SB>;
 defm : ST_Pat<truncstorei16, SH>;
 defm : ST_Pat<store, SW>;
 
+def SW_FI : Pseudo<(outs), (ins GPR:$src, MEMii:$addr),
+                   [(store GPR:$src, ADDRii:$addr)]>;
+
 class ALU_ri<bits<3> funct3, string OpcodeStr, SDPatternOperator OpNode> :
       FI<funct3, 0b0010011, (outs GPR:$rd), (ins GPR:$rs1, simm12:$imm12),
          OpcodeStr#"\t$rd, $rs1, $imm12", [(set GPR:$rd, (OpNode GPR:$rs1, simm12:$imm12))]>
@@ -260,6 +274,10 @@ def XORI  : ALU_ri<0b100, "xori", xor>;
 def ORI   : ALU_ri<0b110, "ori", or>;
 def ANDI  : ALU_ri<0b111, "andi", and>;
 
+// Add with a frameindex, used to legalize frameindex copies and necessary to 
+// keep tblgen happy
+def LEA_FI : Pseudo<(outs GPR:$dst), (ins MEMii:$addr), [(set GPR:$dst, ADDRii:$addr)]>;
+
 class SHIFT32_ri<bit arithshift, bits<3> funct3, string OpcodeStr, SDPatternOperator OpNode> :
       FI32Shift<arithshift, funct3, 0b0010011, (outs GPR:$rd), (ins GPR:$rs1, uimm5:$shamt),
          OpcodeStr#"\t$rd, $rs1, $shamt", [(set GPR:$rd, (OpNode GPR:$rs1, uimm5:$shamt))]>
diff --git a/lib/Target/RISCV/RISCVRegisterInfo.cpp b/lib/Target/RISCV/RISCVRegisterInfo.cpp
index ed8bfe98d20..f8cac999b5a 100644
--- a/lib/Target/RISCV/RISCVRegisterInfo.cpp
+++ b/lib/Target/RISCV/RISCVRegisterInfo.cpp
@@ -61,6 +61,7 @@ void RISCVRegisterInfo::eliminateFrameIndex(MachineBasicBlock::iterator II,
   MachineInstr &MI = *II;
   MachineFunction &MF = *MI.getParent()->getParent();
   const TargetFrameLowering *TFI = MF.getSubtarget().getFrameLowering();
+  const TargetInstrInfo *TII = MF.getSubtarget().getInstrInfo();
   DebugLoc DL = MI.getDebugLoc();
 
   unsigned FrameReg = getFrameRegister(MF);
@@ -68,19 +69,45 @@ void RISCVRegisterInfo::eliminateFrameIndex(MachineBasicBlock::iterator II,
   int Offset = TFI->getFrameIndexReference(MF, FrameIndex, FrameReg);
   Offset += MI.getOperand(FIOperandNum + 1).getImm();
 
+  unsigned Reg = MI.getOperand(0).getReg();
+  assert(RISCV::GPRRegClass.contains(Reg) && "Unexpected register operand");
+
   if (!TFI->hasFP(MF)) {
     report_fatal_error("eliminateFrameIndex currently requires hasFP");
   }
 
+  MachineBasicBlock &MBB = *MI.getParent();
+
   // If the offset fits in an immediate, then directly encode it
   if (isInt<12>(Offset)) {
-    MI.getOperand(FIOperandNum).ChangeToRegister(FrameReg, false);
-    MI.getOperand(FIOperandNum + 1).ChangeToImmediate(Offset);
-    return;
+    switch (MI.getOpcode()) {
+    case RISCV::LW_FI:
+      BuildMI(MBB, II, DL, TII->get(RISCV::LW), Reg)
+          .addReg(FrameReg)
+          .addImm(Offset);
+      break;
+    case RISCV::SW_FI:
+      BuildMI(MBB, II, DL, TII->get(RISCV::SW))
+          .addReg(Reg, getKillRegState(MI.getOperand(0).isKill()))
+          .addReg(FrameReg)
+          .addImm(Offset);
+      break;
+    case RISCV::LEA_FI:
+      BuildMI(MBB, II, DL, TII->get(RISCV::ADDI), Reg)
+          .addReg(FrameReg)
+          .addImm(Offset);
+      break;
+    default:
+      llvm_unreachable("Unexpected opcode");
+    }
   } else {
     report_fatal_error(
         "Frame offsets outside of the signed 12-bit range not supported");
   }
+
+  // Erase old instruction.
+  MBB.erase(II);
+  return;
 }
 
 unsigned RISCVRegisterInfo::getFrameRegister(const MachineFunction &MF) const {
diff --git a/test/CodeGen/RISCV/frame.ll b/test/CodeGen/RISCV/frame.ll
new file mode 100644
index 00000000000..ae6c4aa5e12
--- /dev/null
+++ b/test/CodeGen/RISCV/frame.ll
@@ -0,0 +1,33 @@
+; RUN: llc -mtriple=riscv32 -verify-machineinstrs < %s | FileCheck %s
+
+%struct.key_t = type { i32, [16 x i8] }
+
+; FIXME: prologue and epilogue insertion must be implemented to complete this
+; test
+
+; Function Attrs: nounwind uwtable
+define i32 @test() {
+; CHECK-LABEL: test:
+; CHECK: sw ra, 20(s0)
+; CHECK: sw zero, 16(s0)
+; CHECK: sw zero, 12(s0)
+; CHECK: sw zero, 8(s0)
+; CHECK: sw zero, 4(s0)
+; CHECK: sw zero, 0(s0)
+; CHECK: addi a0, s0, 0
+; CHECK: ori a0, a0, 4
+; CHECK: lui a1, %hi(test1)
+; CHECK: addi a1, a1, %lo(test1)
+; CHECK: jalr ra, a1, 0
+  %key = alloca %struct.key_t, align 4
+  %1 = bitcast %struct.key_t* %key to i8*
+  call void @llvm.memset.p0i8.i64(i8* %1, i8 0, i64 20, i32 4, i1 false)
+  %2 = getelementptr inbounds %struct.key_t, %struct.key_t* %key, i64 0, i32 1, i64 0
+  call void @test1(i8* %2) #3
+  ret i32 0
+}
+
+; Function Attrs: nounwind argmemonly
+declare void @llvm.memset.p0i8.i64(i8* nocapture, i8, i64, i32, i1)
+
+declare void @test1(i8*)
-- 
2.14.1

