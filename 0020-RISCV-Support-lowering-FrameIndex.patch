From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Alex Bradbury <asb@lowrisc.org>
Subject: [RISCV] Support lowering FrameIndex

---
 lib/Target/RISCV/RISCVISelDAGToDAG.cpp | 24 ++++++++++++++++++++++++
 lib/Target/RISCV/RISCVInstrInfo.cpp    |  4 ++--
 lib/Target/RISCV/RISCVInstrInfo.td     | 19 +++++++++++++++++++
 lib/Target/RISCV/RISCVRegisterInfo.cpp | 33 ++++++++++++++++++++++++++++-----
 test/CodeGen/RISCV/frame.ll            | 33 +++++++++++++++++++++++++++++++++
 5 files changed, 106 insertions(+), 7 deletions(-)
 create mode 100644 test/CodeGen/RISCV/frame.ll

diff --git a/lib/Target/RISCV/RISCVISelDAGToDAG.cpp b/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
index e6515b511c8..22bc2b322ca 100644
--- a/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
+++ b/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
@@ -36,6 +36,8 @@ public:
 
   void Select(SDNode *Node) override;
 
+  bool SelectADDRii(SDValue Addr, SDValue &Base, SDValue &Offset);
+
 // Include the pieces autogenerated from the target description.
 #include "RISCVGenDAGISel.inc"
 };
@@ -78,6 +80,28 @@ void RISCVDAGToDAGISel::Select(SDNode *Node) {
   SelectCode(Node);
 }
 
+bool RISCVDAGToDAGISel::SelectADDRii(SDValue Addr, SDValue &Base,
+                                     SDValue &Offset) {
+
+  FrameIndexSDNode *FIN = nullptr;
+  if ((FIN = dyn_cast<FrameIndexSDNode>(Addr))) {
+    Base = CurDAG->getTargetFrameIndex(FIN->getIndex(), MVT::i32);
+    Offset = CurDAG->getTargetConstant(0, SDLoc(Addr), MVT::i32);
+    return true;
+  }
+  if (Addr.getOpcode() == ISD::ADD || Addr.getOpcode() == ISD::OR) {
+    ConstantSDNode *CN = nullptr;
+    if ((FIN = dyn_cast<FrameIndexSDNode>(Addr.getOperand(0))) &&
+        (CN = dyn_cast<ConstantSDNode>(Addr.getOperand(1)))) {
+      Base = CurDAG->getTargetFrameIndex(FIN->getIndex(), MVT::i32);
+      Offset =
+          CurDAG->getTargetConstant(CN->getSExtValue(), SDLoc(Addr), MVT::i32);
+      return true;
+    }
+  }
+  return false;
+}
+
 // This pass converts a legalized DAG into a RISCV-specific DAG, ready
 // for instruction scheduling.
 FunctionPass *llvm::createRISCVISelDag(RISCVTargetMachine &TM) {
diff --git a/lib/Target/RISCV/RISCVInstrInfo.cpp b/lib/Target/RISCV/RISCVInstrInfo.cpp
index c5a0288259d..dca1dda9e15 100644
--- a/lib/Target/RISCV/RISCVInstrInfo.cpp
+++ b/lib/Target/RISCV/RISCVInstrInfo.cpp
@@ -55,7 +55,7 @@ void RISCVInstrInfo::storeRegToStackSlot(MachineBasicBlock &MBB,
     DL = I->getDebugLoc();
 
   if (RC == &RISCV::GPRRegClass)
-    BuildMI(MBB, I, DL, get(RISCV::SW))
+    BuildMI(MBB, I, DL, get(RISCV::SW_FI))
         .addReg(SrcReg, getKillRegState(IsKill))
         .addFrameIndex(FI)
         .addImm(0);
@@ -73,7 +73,7 @@ void RISCVInstrInfo::loadRegFromStackSlot(MachineBasicBlock &MBB,
     DL = I->getDebugLoc();
 
   if (RC == &RISCV::GPRRegClass)
-    BuildMI(MBB, I, DL, get(RISCV::LW), DestReg).addFrameIndex(FI).addImm(0);
+    BuildMI(MBB, I, DL, get(RISCV::LW_FI), DestReg).addFrameIndex(FI).addImm(0);
   else
     llvm_unreachable("Can't load this register from stack slot");
 }
diff --git a/lib/Target/RISCV/RISCVInstrInfo.td b/lib/Target/RISCV/RISCVInstrInfo.td
index 80a21d63f65..10030536abe 100644
--- a/lib/Target/RISCV/RISCVInstrInfo.td
+++ b/lib/Target/RISCV/RISCVInstrInfo.td
@@ -97,6 +97,14 @@ def simm21_lsb0 : Operand<OtherVT> {
   let DecoderMethod = "decodeSImmOperandAndLsl1<21>";
 }
 
+// Addressing modes
+def ADDRii : ComplexPattern<i32, 2, "SelectADDRii", [add, frameindex], []>;
+
+// Address operands
+def MEMii : Operand<i32> {
+  let MIOperandInfo = (ops i32imm, i32imm);
+}
+
 // Extract least significant 12 bits from an immediate value and sign extend
 // them.
 def LO12Sext : SDNodeXForm<imm, [{
@@ -297,6 +305,10 @@ def : PatGprUimm5<srl, SRLI>;
 def : PatGprGpr<sra, SRA>;
 def : PatGprUimm5<sra, SRAI>;
 
+// Add with a frameindex, used to legalize frameindex copies and necessary to
+// keep tblgen happy
+def LEA_FI : Pseudo<(outs GPR:$dst), (ins MEMii:$addr), [(set GPR:$dst, ADDRii:$addr)]>;
+
 /// Setcc
 
 def : PatGprGpr<setlt, SLT>;
@@ -382,6 +394,10 @@ defm : LdPat<load, LW>;
 defm : LdPat<zextloadi8, LBU>;
 defm : LdPat<zextloadi16, LHU>;
 
+def LW_FI : Pseudo<(outs GPR:$dst), (ins MEMii:$addr),
+                   [(set GPR:$dst, (load ADDRii:$addr))]>;
+
+
 /// Stores
 
 multiclass StPat<PatFrag StoreOp, RISCVInst Inst> {
@@ -393,6 +409,9 @@ defm : StPat<truncstorei8, SB>;
 defm : StPat<truncstorei16, SH>;
 defm : StPat<store, SW>;
 
+def SW_FI : Pseudo<(outs), (ins GPR:$src, MEMii:$addr),
+                   [(store GPR:$src, ADDRii:$addr)]>;
+
 /// Other pseudo-instructions
 
 // Pessimistically assume the stack pointer will be clobbered
diff --git a/lib/Target/RISCV/RISCVRegisterInfo.cpp b/lib/Target/RISCV/RISCVRegisterInfo.cpp
index 37157de882f..6fdfc1589ca 100644
--- a/lib/Target/RISCV/RISCVRegisterInfo.cpp
+++ b/lib/Target/RISCV/RISCVRegisterInfo.cpp
@@ -56,14 +56,12 @@ const uint32_t *RISCVRegisterInfo::getNoPreservedMask() const {
 void RISCVRegisterInfo::eliminateFrameIndex(MachineBasicBlock::iterator II,
                                             int SPAdj, unsigned FIOperandNum,
                                             RegScavenger *RS) const {
-  // TODO: this implementation is a temporary placeholder which does just
-  // enough to allow other aspects of code generation to be tested
-
   assert(SPAdj == 0 && "Unexpected non-zero SPAdj value");
 
   MachineInstr &MI = *II;
   MachineFunction &MF = *MI.getParent()->getParent();
   const TargetFrameLowering *TFI = MF.getSubtarget().getFrameLowering();
+  const TargetInstrInfo *TII = MF.getSubtarget().getInstrInfo();
   DebugLoc DL = MI.getDebugLoc();
 
   unsigned FrameReg = getFrameRegister(MF);
@@ -71,6 +69,9 @@ void RISCVRegisterInfo::eliminateFrameIndex(MachineBasicBlock::iterator II,
   int Offset = TFI->getFrameIndexReference(MF, FrameIndex, FrameReg);
   Offset += MI.getOperand(FIOperandNum + 1).getImm();
 
+  unsigned Reg = MI.getOperand(0).getReg();
+  assert(RISCV::GPRRegClass.contains(Reg) && "Unexpected register operand");
+
   assert(TFI->hasFP(MF) && "eliminateFrameIndex currently requires hasFP");
 
   // Offsets must be directly encoded in a 12-bit immediate field
@@ -79,8 +80,30 @@ void RISCVRegisterInfo::eliminateFrameIndex(MachineBasicBlock::iterator II,
         "Frame offsets outside of the signed 12-bit range not supported");
   }
 
-  MI.getOperand(FIOperandNum).ChangeToRegister(FrameReg, false);
-  MI.getOperand(FIOperandNum + 1).ChangeToImmediate(Offset);
+  MachineBasicBlock &MBB = *MI.getParent();
+  switch (MI.getOpcode()) {
+  case RISCV::LW_FI:
+    BuildMI(MBB, II, DL, TII->get(RISCV::LW), Reg)
+        .addReg(FrameReg)
+        .addImm(Offset);
+    break;
+  case RISCV::SW_FI:
+    BuildMI(MBB, II, DL, TII->get(RISCV::SW))
+        .addReg(Reg, getKillRegState(MI.getOperand(0).isKill()))
+        .addReg(FrameReg)
+        .addImm(Offset);
+    break;
+  case RISCV::LEA_FI:
+    BuildMI(MBB, II, DL, TII->get(RISCV::ADDI), Reg)
+        .addReg(FrameReg)
+        .addImm(Offset);
+    break;
+  default:
+    llvm_unreachable("Unexpected opcode");
+  }
+
+  // Erase old instruction.
+  MBB.erase(II);
   return;
 }
 
diff --git a/test/CodeGen/RISCV/frame.ll b/test/CodeGen/RISCV/frame.ll
new file mode 100644
index 00000000000..ae6c4aa5e12
--- /dev/null
+++ b/test/CodeGen/RISCV/frame.ll
@@ -0,0 +1,33 @@
+; RUN: llc -mtriple=riscv32 -verify-machineinstrs < %s | FileCheck %s
+
+%struct.key_t = type { i32, [16 x i8] }
+
+; FIXME: prologue and epilogue insertion must be implemented to complete this
+; test
+
+; Function Attrs: nounwind uwtable
+define i32 @test() {
+; CHECK-LABEL: test:
+; CHECK: sw ra, 20(s0)
+; CHECK: sw zero, 16(s0)
+; CHECK: sw zero, 12(s0)
+; CHECK: sw zero, 8(s0)
+; CHECK: sw zero, 4(s0)
+; CHECK: sw zero, 0(s0)
+; CHECK: addi a0, s0, 0
+; CHECK: ori a0, a0, 4
+; CHECK: lui a1, %hi(test1)
+; CHECK: addi a1, a1, %lo(test1)
+; CHECK: jalr ra, a1, 0
+  %key = alloca %struct.key_t, align 4
+  %1 = bitcast %struct.key_t* %key to i8*
+  call void @llvm.memset.p0i8.i64(i8* %1, i8 0, i64 20, i32 4, i1 false)
+  %2 = getelementptr inbounds %struct.key_t, %struct.key_t* %key, i64 0, i32 1, i64 0
+  call void @test1(i8* %2) #3
+  ret i32 0
+}
+
+; Function Attrs: nounwind argmemonly
+declare void @llvm.memset.p0i8.i64(i8* nocapture, i8, i64, i32, i1)
+
+declare void @test1(i8*)
-- 
2.14.1

