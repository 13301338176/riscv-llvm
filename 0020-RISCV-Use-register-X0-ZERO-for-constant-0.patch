From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Alex Bradbury <asb@lowrisc.org>
Subject: [RISCV] Use register X0 (ZERO) for constant 0

The obvious approach of defining a pattern like the one below actually doesn't
work:
`def : Pat<(i32 0), (i32 X0)>;`

As was noted when Lanai made this change (https://reviews.llvm.org/rL288215),
attempting to handle the constant 0 in tablegen leads to assertions due to a
physical register being used where a virtual register is expected.
---
 lib/Target/RISCV/RISCVISelDAGToDAG.cpp | 29 +++++++++++++++++++++++++++++
 test/CodeGen/RISCV/bare-select.ll      |  3 +--
 test/CodeGen/RISCV/sext-zext-trunc.ll  | 19 ++++---------------
 3 files changed, 34 insertions(+), 17 deletions(-)

diff --git a/lib/Target/RISCV/RISCVISelDAGToDAG.cpp b/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
index 78f61fa4184..4a85f719743 100644
--- a/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
+++ b/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
@@ -26,6 +26,7 @@ using namespace llvm;
 // SelectionDAG operations.
 namespace {
 class RISCVDAGToDAGISel final : public SelectionDAGISel {
+  const RISCVSubtarget *Subtarget;
 public:
   explicit RISCVDAGToDAGISel(RISCVTargetMachine &TargetMachine)
       : SelectionDAGISel(TargetMachine) {}
@@ -34,6 +35,11 @@ public:
     return "RISCV DAG->DAG Pattern Instruction Selection";
   }
 
+  bool runOnMachineFunction(MachineFunction &MF) override {
+    Subtarget = &MF.getSubtarget<RISCVSubtarget>();
+    return SelectionDAGISel::runOnMachineFunction(MF);
+  }
+
   void Select(SDNode *Node) override;
 
 // Include the pieces autogenerated from the target description.
@@ -42,6 +48,9 @@ public:
 }
 
 void RISCVDAGToDAGISel::Select(SDNode *Node) {
+  unsigned Opcode = Node->getOpcode();
+  MVT XLenVT = Subtarget->getXLenVT();
+
   // Dump information about the Node being selected.
   DEBUG(dbgs() << "Selecting: "; Node->dump(CurDAG); dbgs() << "\n");
 
@@ -52,6 +61,26 @@ void RISCVDAGToDAGISel::Select(SDNode *Node) {
     return;
   }
 
+  // Instruction Selection not handled by the auto-generated tablegen selection
+  // should be handled here.
+  EVT VT = Node->getValueType(0);
+  switch (Opcode) {
+  case ISD::Constant:
+    if (VT == XLenVT) {
+      ConstantSDNode *ConstNode = cast<ConstantSDNode>(Node);
+      // Materialize zero constants as copies from X0. This allows the coalescer
+      // to propagate these into other instructions.
+      if (ConstNode->isNullValue()) {
+        SDValue New = CurDAG->getCopyFromReg(
+            CurDAG->getEntryNode(), SDLoc(Node), RISCV::X0, XLenVT);
+        return ReplaceNode(Node, New.getNode());
+      }
+    }
+    break;
+  default:
+    break;
+  }
+
   // Select the default instruction.
   SelectCode(Node);
 }
diff --git a/test/CodeGen/RISCV/bare-select.ll b/test/CodeGen/RISCV/bare-select.ll
index 19edff7cf5a..db0332443c0 100644
--- a/test/CodeGen/RISCV/bare-select.ll
+++ b/test/CodeGen/RISCV/bare-select.ll
@@ -4,8 +4,7 @@
 define i32 @bare_select(i1 %a, i32 %b, i32 %c) {
 ; RV32I-LABEL: bare_select:
 ; RV32I: andi a0, a0, 1
-; RV32I: addi a3, zero, 0
-; RV32I: bne a0, a3, .LBB0_2
+; RV32I: bne a0, zero, .LBB0_2
 ; RV32I: addi a1, a2, 0
 ; RV32I: .LBB0_2:
 ; RV32I: addi a0, a1, 0
diff --git a/test/CodeGen/RISCV/sext-zext-trunc.ll b/test/CodeGen/RISCV/sext-zext-trunc.ll
index 00583cf43d0..92d8613ff7a 100644
--- a/test/CodeGen/RISCV/sext-zext-trunc.ll
+++ b/test/CodeGen/RISCV/sext-zext-trunc.ll
@@ -1,45 +1,34 @@
 ; RUN: llc -mtriple=riscv32 -verify-machineinstrs < %s \
 ; RUN:   | FileCheck %s -check-prefix=RV32I
 
-; FIXME: an unncessary register is allocated just to store 0. X0 should be
-; used instead
-
 define i8 @sext_i1_to_i8(i1 %a) {
-; TODO: the addi that stores 0 in t1 is unnecessary
 ; RV32I-LABEL: sext_i1_to_i8
 ; RV32I: andi a0, a0, 1
-; RV32I: addi a1, zero, 0
-; RV32I: sub a0, a1, a0
+; RV32I: sub a0, zero, a0
   %1 = sext i1 %a to i8
   ret i8 %1
 }
 
 define i16 @sext_i1_to_i16(i1 %a) {
-; TODO: the addi that stores 0 in t1 is unnecessary
 ; RV32I-LABEL: sext_i1_to_i16
 ; RV32I: andi a0, a0, 1
-; RV32I: addi a1, zero, 0
-; RV32I: sub a0, a1, a0
+; RV32I: sub a0, zero, a0
   %1 = sext i1 %a to i16
   ret i16 %1
 }
 
 define i32 @sext_i1_to_i32(i1 %a) {
-; TODO: the addi that stores 0 in t1 is unnecessary
 ; RV32I-LABEL: sext_i1_to_i32
 ; RV32I: andi a0, a0, 1
-; RV32I: addi a1, zero, 0
-; RV32I: sub a0, a1, a0
+; RV32I: sub a0, zero, a0
   %1 = sext i1 %a to i32
   ret i32 %1
 }
 
 define i64 @sext_i1_to_i64(i1 %a) {
-; TODO: the addi that stores 0 in t1 is unnecessary
 ; RV32I-LABEL: sext_i1_to_i64
 ; RV32I: andi a0, a0, 1
-; RV32I: addi a1, zero, 0
-; RV32I: sub a0, a1, a0
+; RV32I: sub a0, zero, a0
   %1 = sext i1 %a to i64
   ret i64 %1
 }
-- 
2.14.2

