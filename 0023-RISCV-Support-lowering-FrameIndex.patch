From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Alex Bradbury <asb@lowrisc.org>
Subject: [RISCV] Support lowering FrameIndex

---
 lib/Target/RISCV/RISCVISelDAGToDAG.cpp | 24 ++++++++++++++++++++++
 lib/Target/RISCV/RISCVInstrInfo.cpp    |  4 ++--
 lib/Target/RISCV/RISCVInstrInfo.td     | 21 ++++++++++++++++++-
 lib/Target/RISCV/RISCVRegisterInfo.cpp | 33 +++++++++++++++++++++++++-----
 test/CodeGen/RISCV/frame.ll            | 37 ++++++++++++++++++++++++++++++++++
 5 files changed, 111 insertions(+), 8 deletions(-)
 create mode 100644 test/CodeGen/RISCV/frame.ll

diff --git a/lib/Target/RISCV/RISCVISelDAGToDAG.cpp b/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
index 4a85f719743..4c6e03a5918 100644
--- a/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
+++ b/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
@@ -42,6 +42,8 @@ public:
 
   void Select(SDNode *Node) override;
 
+  bool SelectADDRii(SDValue Addr, SDValue &Base, SDValue &Offset);
+
 // Include the pieces autogenerated from the target description.
 #include "RISCVGenDAGISel.inc"
 };
@@ -85,6 +87,28 @@ void RISCVDAGToDAGISel::Select(SDNode *Node) {
   SelectCode(Node);
 }
 
+bool RISCVDAGToDAGISel::SelectADDRii(SDValue Addr, SDValue &Base,
+                                     SDValue &Offset) {
+
+  FrameIndexSDNode *FIN = nullptr;
+  if ((FIN = dyn_cast<FrameIndexSDNode>(Addr))) {
+    Base = CurDAG->getTargetFrameIndex(FIN->getIndex(), MVT::i32);
+    Offset = CurDAG->getTargetConstant(0, SDLoc(Addr), MVT::i32);
+    return true;
+  }
+  if (Addr.getOpcode() == ISD::ADD || Addr.getOpcode() == ISD::OR) {
+    ConstantSDNode *CN = nullptr;
+    if ((FIN = dyn_cast<FrameIndexSDNode>(Addr.getOperand(0))) &&
+        (CN = dyn_cast<ConstantSDNode>(Addr.getOperand(1)))) {
+      Base = CurDAG->getTargetFrameIndex(FIN->getIndex(), MVT::i32);
+      Offset =
+          CurDAG->getTargetConstant(CN->getSExtValue(), SDLoc(Addr), MVT::i32);
+      return true;
+    }
+  }
+  return false;
+}
+
 // This pass converts a legalized DAG into a RISCV-specific DAG, ready
 // for instruction scheduling.
 FunctionPass *llvm::createRISCVISelDag(RISCVTargetMachine &TM) {
diff --git a/lib/Target/RISCV/RISCVInstrInfo.cpp b/lib/Target/RISCV/RISCVInstrInfo.cpp
index e1b5036f491..65f80d77570 100644
--- a/lib/Target/RISCV/RISCVInstrInfo.cpp
+++ b/lib/Target/RISCV/RISCVInstrInfo.cpp
@@ -54,7 +54,7 @@ void RISCVInstrInfo::storeRegToStackSlot(MachineBasicBlock &MBB,
     DL = I->getDebugLoc();
 
   if (RC == &RISCV::GPRRegClass)
-    BuildMI(MBB, I, DL, get(RISCV::SW))
+    BuildMI(MBB, I, DL, get(RISCV::SW_FI))
         .addReg(SrcReg, getKillRegState(IsKill))
         .addFrameIndex(FI)
         .addImm(0);
@@ -72,7 +72,7 @@ void RISCVInstrInfo::loadRegFromStackSlot(MachineBasicBlock &MBB,
     DL = I->getDebugLoc();
 
   if (RC == &RISCV::GPRRegClass)
-    BuildMI(MBB, I, DL, get(RISCV::LW), DstReg).addFrameIndex(FI).addImm(0);
+    BuildMI(MBB, I, DL, get(RISCV::LW_FI), DstReg).addFrameIndex(FI).addImm(0);
   else
     llvm_unreachable("Can't load this register from stack slot");
 }
diff --git a/lib/Target/RISCV/RISCVInstrInfo.td b/lib/Target/RISCV/RISCVInstrInfo.td
index 72d21bde0f5..d873b6f3b1e 100644
--- a/lib/Target/RISCV/RISCVInstrInfo.td
+++ b/lib/Target/RISCV/RISCVInstrInfo.td
@@ -105,12 +105,20 @@ def simm21_lsb0 : Operand<OtherVT> {
   let DecoderMethod = "decodeSImmOperandAndLsl1<21>";
 }
 
-// A parameterized register class alternative for i32imm/i64imm from Target.td.
+// A parameterized register class alternative to i32imm/i64imm from Target.td.
 def ixlenimm : Operand<XLenVT>;
 
 // Standalone (codegen-only) immleaf patterns.
 def simm32 : ImmLeaf<XLenVT, [{return isInt<32>(Imm);}]>;
 
+// Addressing modes.
+def ADDRii : ComplexPattern<iPTR, 2, "SelectADDRii", [add, frameindex], []>;
+
+// Address operands.
+def MEMii : Operand<XLenVT> {
+  let MIOperandInfo = (ops ixlenimm, ixlenimm);
+}
+
 // Extract least significant 12 bits from an immediate value and sign extend
 // them.
 def LO12Sext : SDNodeXForm<imm, [{
@@ -321,6 +329,10 @@ def : PatGprUimm5<srl, SRLI>;
 def : PatGprGpr<sra, SRA>;
 def : PatGprUimm5<sra, SRAI>;
 
+// Add with a frameindex, used to legalize frameindex copies and necessary to
+// keep tblgen happy
+def LEA_FI : Pseudo<(outs GPR:$dst), (ins MEMii:$addr), [(set GPR:$dst, ADDRii:$addr)]>;
+
 /// Setcc
 
 def : PatGprGpr<setlt, SLT>;
@@ -413,6 +425,10 @@ defm : LdPat<load, LW>;
 defm : LdPat<zextloadi8, LBU>;
 defm : LdPat<zextloadi16, LHU>;
 
+def LW_FI : Pseudo<(outs GPR:$dst), (ins MEMii:$addr),
+                   [(set GPR:$dst, (load ADDRii:$addr))]>;
+
+
 /// Stores
 
 multiclass StPat<PatFrag StoreOp, RVInst Inst> {
@@ -425,6 +441,9 @@ defm : StPat<truncstorei8, SB>;
 defm : StPat<truncstorei16, SH>;
 defm : StPat<store, SW>;
 
+def SW_FI : Pseudo<(outs), (ins GPR:$src, MEMii:$addr),
+                   [(store GPR:$src, ADDRii:$addr)]>;
+
 /// Other pseudo-instructions
 
 // Pessimistically assume the stack pointer will be clobbered
diff --git a/lib/Target/RISCV/RISCVRegisterInfo.cpp b/lib/Target/RISCV/RISCVRegisterInfo.cpp
index cd658d7e2d9..4e173b1edd6 100644
--- a/lib/Target/RISCV/RISCVRegisterInfo.cpp
+++ b/lib/Target/RISCV/RISCVRegisterInfo.cpp
@@ -57,14 +57,12 @@ const uint32_t *RISCVRegisterInfo::getNoPreservedMask() const {
 void RISCVRegisterInfo::eliminateFrameIndex(MachineBasicBlock::iterator II,
                                             int SPAdj, unsigned FIOperandNum,
                                             RegScavenger *RS) const {
-  // TODO: this implementation is a temporary placeholder which does just
-  // enough to allow other aspects of code generation to be tested
-
   assert(SPAdj == 0 && "Unexpected non-zero SPAdj value");
 
   MachineInstr &MI = *II;
   MachineFunction &MF = *MI.getParent()->getParent();
   const TargetFrameLowering *TFI = MF.getSubtarget().getFrameLowering();
+  const TargetInstrInfo *TII = MF.getSubtarget().getInstrInfo();
   DebugLoc DL = MI.getDebugLoc();
 
   unsigned FrameReg = getFrameRegister(MF);
@@ -72,6 +70,9 @@ void RISCVRegisterInfo::eliminateFrameIndex(MachineBasicBlock::iterator II,
   int Offset = TFI->getFrameIndexReference(MF, FrameIndex, FrameReg);
   Offset += MI.getOperand(FIOperandNum + 1).getImm();
 
+  unsigned Reg = MI.getOperand(0).getReg();
+  assert(RISCV::GPRRegClass.contains(Reg) && "Unexpected register operand");
+
   assert(TFI->hasFP(MF) && "eliminateFrameIndex currently requires hasFP");
 
   // Offsets must be directly encoded in a 12-bit immediate field
@@ -80,8 +81,30 @@ void RISCVRegisterInfo::eliminateFrameIndex(MachineBasicBlock::iterator II,
         "Frame offsets outside of the signed 12-bit range not supported");
   }
 
-  MI.getOperand(FIOperandNum).ChangeToRegister(FrameReg, false);
-  MI.getOperand(FIOperandNum + 1).ChangeToImmediate(Offset);
+  MachineBasicBlock &MBB = *MI.getParent();
+  switch (MI.getOpcode()) {
+  case RISCV::LW_FI:
+    BuildMI(MBB, II, DL, TII->get(RISCV::LW), Reg)
+        .addReg(FrameReg)
+        .addImm(Offset);
+    break;
+  case RISCV::SW_FI:
+    BuildMI(MBB, II, DL, TII->get(RISCV::SW))
+        .addReg(Reg, getKillRegState(MI.getOperand(0).isKill()))
+        .addReg(FrameReg)
+        .addImm(Offset);
+    break;
+  case RISCV::LEA_FI:
+    BuildMI(MBB, II, DL, TII->get(RISCV::ADDI), Reg)
+        .addReg(FrameReg)
+        .addImm(Offset);
+    break;
+  default:
+    llvm_unreachable("Unexpected opcode");
+  }
+
+  // Erase old instruction.
+  MBB.erase(II);
   return;
 }
 
diff --git a/test/CodeGen/RISCV/frame.ll b/test/CodeGen/RISCV/frame.ll
new file mode 100644
index 00000000000..0a35f4bb73d
--- /dev/null
+++ b/test/CodeGen/RISCV/frame.ll
@@ -0,0 +1,37 @@
+; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
+; RUN: llc -mtriple=riscv32 -verify-machineinstrs < %s \
+; RUN:   | FileCheck -check-prefix=RV32I %s
+
+%struct.key_t = type { i32, [16 x i8] }
+
+; FIXME: prologue and epilogue insertion must be implemented to complete this
+; test
+
+define i32 @test() nounwind {
+; RV32I-LABEL: test:
+; RV32I:       # BB#0:
+; RV32I-NEXT:    sw ra, 28(s0)
+; RV32I-NEXT:    sw zero, 24(s0)
+; RV32I-NEXT:    sw zero, 20(s0)
+; RV32I-NEXT:    sw zero, 16(s0)
+; RV32I-NEXT:    sw zero, 12(s0)
+; RV32I-NEXT:    sw zero, 8(s0)
+; RV32I-NEXT:    addi a0, s0, 8
+; RV32I-NEXT:    ori a0, a0, 4
+; RV32I-NEXT:    lui a1, %hi(test1)
+; RV32I-NEXT:    addi a1, a1, %lo(test1)
+; RV32I-NEXT:    jalr ra, a1, 0
+; RV32I-NEXT:    addi a0, zero, 0
+; RV32I-NEXT:    lw ra, 28(s0)
+; RV32I-NEXT:    jalr zero, ra, 0
+  %key = alloca %struct.key_t, align 4
+  %1 = bitcast %struct.key_t* %key to i8*
+  call void @llvm.memset.p0i8.i64(i8* %1, i8 0, i64 20, i32 4, i1 false)
+  %2 = getelementptr inbounds %struct.key_t, %struct.key_t* %key, i64 0, i32 1, i64 0
+  call void @test1(i8* %2) #3
+  ret i32 0
+}
+
+declare void @llvm.memset.p0i8.i64(i8* nocapture, i8, i64, i32, i1)
+
+declare void @test1(i8*)
-- 
2.15.0

